
PROGRAM is measured using TIME & SPACE Complexity.
 - TIME : CPU Time + I/O time
   a) During I/O time cpu is idle. So inorder to increase the efficiency of CPU more processes has to be loaded in to RAM
      Example: P is the fraction of time taken by the process to complete I/O operation then time taken by the CPU is (1 - P)
       
       --------------------------------------------------
       #Processes in RAM             I/O Time       CPU TIME
       -------------------------------------------------- 
         1                            P             (1 - P) 
         4                         P*P*P*P          (1 - P*P*P*P)  CPU Efficiency is increased.
      
      More Processes in RAM , More CPU Utilization.
      
   b) Managing more process in RAM is called Memory Management & it is acheived using memory partioning
      (i) STATIC ( Contigious Allocation ): RAM is partioned into fixed sizes to load processes and relocation addresses are calculated by MMU using
          LIMIT & RELOCATION Registers
          LIMIT REGISTER: Holds the size of the process
          RELOCATION REGISTER: Holds the Base address of the process in RAM
          Relocation during process Load time has some issues, so relocation has to be done at Runtime 
          Relocation Address: Converting Logical Address generated by CPU into Physical address 
           
          Drawbacks: Internal Fragmentation & External Fragmentation
          
      (ii) DYNAMIC ( Non-Contigious Allocation ) :  
           - Solved Internal fragmentation  problem using Non Contigious allocation technique
           DRAWBACK: External fragmentation still exists. E.g: If the new processes cannot fit in the holes of the completed 
           processes.
           There are 2 techniques
           a) COMPACTION:
              DRAWBACK: Takes some time & CPU will remain idle, which effects its efficiency
           b) PAGING: 
              (i) Process is divided in to PAGES
              (ii) RAM is divided in to FRAMES, where size of each FRAME == Size of each PAGE.
              Just like limit & relocation registers used during relocatable address calculation at STATIC Partitioning, here
              each Process will maintain a PAGE TABLE which holds the location of a page in the RAM.
      

PROCESS CREATION
==============================================================================================================================      

PROGRAM --> COMPILER --> ASSEMBLY CODE --> ASSEMBLER --> OBJECT CODE

Now a days compiler software has internally has LOADER , LINKER & ASSEMBLER.

PROGRAM --> COMPILER --> OBJECT CODE

- Once Compiled ObjectCode is stored in the Harddisk & it looks like below.

                               OBJECT CODE  
                          ***********************

                          |------------------|
                          |    HEADER        |
                          |------------------|
                          |  Text Segment    |
                          |------------------|
                          |  Data Segment    |
                          |------------------|
                          | Relocation Info  |
                          |------------------|
                          |  Symbol Table    |
                          |------------------|
                          | Debugging Info   |
                          |------------------|

The output generated by Compiler & Assembler contains RELOCATABLE Addresses, which has to be changed to absolute address before
loading into memory.

PROGRAM ==> ( COMPILER + ASSEMBLER ) ==> PROGRAM WITH RELOCATBLE ADDRESS 

when compiling the problem, it doesnt know where it will loaded in main memory, so it will assume that it will start loading 
instructions starting from Address ZERO & will number all instructions accordingly.


RELOCATION: Using Relocation Info, every rellocatable address is converted to Absolute address before it loading the program.






PROCESS SYNCHRONIZATION
==============================================================================================================================

Process 1                                  Process 2 
|----------|                             |-----------|
|   {      |                             |    {      |    
|   ...    |      CRITICAL SECTION       |    ...    |
|   ...    |   %%%%%%%%%%%%%%%%%%%%%%    |    ...    |
| count -- |   %       Count         %   |   count++ |
|   ...    |   %%%%%%%%%%%%%%%%%%%%%%    |    ...    |
|   }      |                             |    }      |
|__________|                             |___________|

Single line code is converted to 3 lines in Assembly Language
    MOV count R0
    INCR R0
    MOV R0 count
 
 Mutual Exclusion: If one process is in crtical section then it should not allow other process to enter critical section.
 RACE CONDITION: The output is decided by the order in which the process gets executed.
 
 Rules for Synchronization:
 - Mutual Exclusion
 - Progress : 
 - Bounded waiting: should say after how manytimes you will get chance.
 - Portability / Architectural Neutrality : 
  
              ENTRY SECTION
                   |
              CRITICAL SECTION   
                   |
              EXIT SECTION     
 
 Synchronization Mechanisms are of 2 types
 - Busy waiting ( Continuously knocking the door)
    a) Lock Mechanism
    b) TSL instruction provided by OS
    c) Disable Interrupt: not useful because it is not a user mode.
    d) Peterson Solution
    
    ** Note: All busy wait synchdronization mechanisms have 2 common problems
      (i) CPU time get wasted because of busy waiting
      (ii) Priority Inversion problem, that leads to SPIN lock.
    
 - without busy waiting : 
    a) Sleep & Wake.
       - Producer/Consumer problem
    
 1) LOCK Mechanishm: 
    - Software mechanism implemented in User Mode.
    - It is a busy waiting solution, and it can be used for more than 2 processes
    - if LOCK = 1 then it means Occupied,  LOCK = 0 then Vacant
 
              ENTRY SECTION [ while( LOCK !=0 ); LOCK=1; ]
                   |
              CRITICAL SECTION   
                   |
              EXIT SECTION [ LOCK=0; ]
              
      Example: Dressing Room - Door Knob hanging a tag ( Vacant / Occupied )
     
          a) P1 checks the room and is Vacant, just before changing the tag .. it is moved to ready queue becz of premption.
          b) P2 checks the room and is Vacant hence it changes Tag to Occupied and enters CS
          c) P1 now comes back, since it already checked it is vacant earlier, so enters CS directly without checking again
          d) Both are in CS & Mutual Exlusion failed
          
       1. LOAD LOCK R0
       2. CMP R0, #0
       3. JNZ step1
       4. store #1, LOCK
          CRITICAL SECTION
       5. store #0, LOCK
       
       P1:(1), Prempted | P2: (1,2,3,4 CS ) | P1: (2,3,4 CS ) 
       Both P1 & P2 are in CS , so Mutual Exclusion got failed.
     
     Hence LOCK solution got failed.
     
    2) TSL
       
     |----------------------|---------------------|----------------------------------------------
     | SOLUTION 1: LOCK     | SOLUTION 2 : LOCK   |  SOLUTION 3: TSL Instruction by OS
     |______________________|_____________________|______________________________________________
     | 1. LOAD LOCK R0      | 1. LOAD LOCK R0     | 1. [ LOAD LOCK R0 ; STORE #1, LOCK ]
     | 2. CMP R0, #0        | 2. STORE #1, LOCK   |     Atomic Operation using TSL Instruction 
     | 3. JNZ step1         | 3. CMP R0, #0       | 2. CMP R0, #0
     | 4. STORE #1, LOCK    | 4. JNZ step1        | 3. JNZ step1
     |    Critical Section  |    Critical Section |    Critical Section
     | 5. STORE #0, LOCK    | 5. STORE #0, LOCK   | 4. STORE #0, LOCK
     |______________________|_____________________|______________________________________________
     |                      |                     |
     | P1:(1), Prempted     | P1:(1), Prempted    | P1:(1), Prempted
     | P2: (1,2,3,4 CS )    | P2: (1,2,3,4 CS )   | p2:(1,2,3,1,2,3,1...)
     | P1: (2,3,4 CS )      | P1: (2,3,4 CS )     |
     |______________________|_____________________|______________________________________________
     | Both P1&2 are in CS  | Both P1&2 are in CS | Only one is in CS
     | No Mutual Exclusion  | No Mutual Exclusion | Mutual Exclusion possible.
     |                      |                     | Bounded Waiting is not guaranteed
     |                      |                     | Starvation Possible
     |                      |                     | Architectual Dependent. 
     |                      |                     | Priority Inversion Problem
     |                      |                     |  
     
     Priority Inversion Problem: 
     - P1 enter into CS
     - Because of priority scheduling algorithm, P1 got prempted & P2 has to enter CS
     - Since LOCK variable is set by P1, P2 cant enter CS.
     - P1 cannot enter CS since it got prempted and wating for P2 to get finish
     - Here it goes dead/spin lock.
    

