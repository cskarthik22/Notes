
PROCESS CREATION
==============================================================================================================================

PROGRAM --> COMPILER --> ASSEMBLY CODE --> ASSEMBLER --> OBJECT CODE

Now a days compiler software has internally has LOADER , LINKER & ASSEMBLER.

PROGRAM --> COMPILER --> OBJECT CODE

- Once Compiled ObjectCode is stored in the Harddisk & it looks like below.

                               OBJECT CODE  
                          ***********************

                          |------------------|
                          |    HEADER        |
                          |------------------|
                          |  Text Segment    |
                          |------------------|
                          |  Data Segment    |
                          |------------------|
                          | Relocation Info  |
                          |------------------|
                          |  Symbol Table    |
                          |------------------|
                          | Debugging Info   |
                          |------------------|

The output generated by Compiler & Assembler contains RELOCATABLE Addresses, which has to be changed to absolute address before
loading into memory.

PROGRAM ==> ( COMPILER + ASSEMBLER ) ==> PROGRAM WITH RELOCATBLE ADDRESS 

when compiling the problem, it doesnt know where it will loaded in main memory, so it will assume that it will start loading 
instructions starting from Address ZERO & will number all instructions accordingly.


RELOCATION: Using Relocation Info, every rellocatable address is converted to Absolute address before it loading the program.






PROCESS SYNCHRONIZATION
==============================================================================================================================

Process 1                                  Process 2 
|----------|                             |-----------|
|   {      |                             |    {      |    
|   ...    |      CRITICAL SECTION       |    ...    |
|   ...    |   %%%%%%%%%%%%%%%%%%%%%%    |    ...    |
| count -- |   %       Count         %   |   count++ |
|   ...    |   %%%%%%%%%%%%%%%%%%%%%%    |    ...    |
|   }      |                             |    }      |
|__________|                             |___________|

Single line code is converted to 3 lines in Assembly Language
    MOV count R0
    INCR R0
    MOV R0 count
 
 Mutual Exclusion: If one process is in crtical section then it should not allow other process to enter critical section.
 RACE CONDITION: The output is decided by the order in which the process gets executed.
 
 Rules for Synchronization:
 - Mutual Exclusion
 - Progress : 
 - Bounded waiting: should say after how manytimes you will get chance.
 - Portability / Architectural Neutrality : 
  
              ENTRY SECTION
                   |
              CRITICAL SECTION   
                   |
              EXIT SECTION     
 
 Synchronization Mechanisms are of 2 types
 - Busy waiting 
    a) Continuously knocking the door
 - without busy waiting : 
    a) check b) go & sleep 
    
 1) LOCK Mechanishm: 
    - Software mechanism implemented in User Mode.
    - It is a busy waiting solution, and it can be used for more than 2 processes
    - if LOCK = 1 then it means Occupied,  LOCK = 0 then Vacant
 
              ENTRY SECTION [ while( LOCK !=0 ); LOCK=1; ]
                   |
              CRITICAL SECTION   
                   |
              EXIT SECTION [ LOCK=0; ]
              
      Example: Dressing Room - Door Knob hanging a tag ( Vacant / Occupied )
      cons: 
        - busy waiting doing nothing at while loop
        - No mutual exclusion provided becuase all processes can enter CS.
          e.g: 
          a) P1 checks the room and is Vacant, just before changing the tag .. it is moved to ready queue becz of premption.
          b) P2 checks the room and is Vacant hence it changes Tag to Occupied and enters CS
          c) P1 now comes back, since it already checked it is vacant earlier, so enters CS directly without checking again
          d) Both are in CS & Mutual Exlusion failed
          
       1. LOAD LOCK R0
       2. CMP R0, #0
       3. JNZ step1
       4. store #1, LOCK
          CRITICAL SECTION
       5. store #0, LOCK
       
       P1:(1), Prempted | P2: (1,2,3,4 CS ) | P1: (2,3,4 CS ) 
       Both P1 & P2 are in CS , so Mutual Exclusion got failed.
     
     Hence LOCK solution got failed.
     
    2) TSL
       
     |----------------------|---------------------|----------------------------------------------
     | SOLUTION 1: LOCK     | SOLUTION 2 : LOCK   |  SOLUTION 3: TSL Instruction by OS
     |______________________|_____________________|______________________________________________
     | 1. LOAD LOCK R0      | 1. LOAD LOCK R0     | 1. [ LOAD LOCK R0 ; STORE #1, LOCK ]
     | 2. CMP R0, #0        | 2. STORE #1, LOCK   |     Atomic Operation using TSL Instruction 
     | 3. JNZ step1         | 3. CMP R0, #0       | 2. CMP R0, #0
     | 4. STORE #1, LOCK    | 4. JNZ step1        | 3. JNZ step1
     |    Critical Section  |    Critical Section |    Critical Section
     | 5. STORE #0, LOCK    | 5. STORE #0, LOCK   | 4. STORE #0, LOCK
     |______________________|_____________________|______________________________________________
     |                      |                     |
     | P1:(1), Prempted     | P1:(1), Prempted    | P1:(1), Prempted
     | P2: (1,2,3,4 CS )    | P2: (1,2,3,4 CS )   | p2:(1,2,3,1,2,3,1...)
     | P1: (2,3,4 CS )      | P1: (2,3,4 CS )     |
     |______________________|_____________________|______________________________________________
     | Both P1&2 are in CS  | Both P1&2 are in CS | Only one is in CS
     | No Mutual Exclusion  | No Mutual Exclusion | Mutual Exclusion possible.
     |                      |                     | Bounded Waiting is not guaranteed
     |                      |                     | Starvation Possible
     |                      |                     | Architectual Dependent. 
     |                      |                     | Priority Inversion Problem
     |                      |                     |  
     
     Priority Inversion Problem: 
     - P1 enter into CS
     - Because of priority scheduling algorithm, P1 got prempted & P2 has to enter CS
     - Since LOCK variable is set by P1, P2 cant enter CS.
     - P1 cannot enter CS since it got prempted and wating for P2 to get finish
     - Here it goes dead/spin lock.
    

